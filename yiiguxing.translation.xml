<application>
  <component name="AppStorage">
    <histories>
      <item value="11&#10;44&#10;22&#10;33" />
      <item value="* &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its {@code add(int, E)} and * {@code remove(int)} methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * {@code add(int, E)} or {@code remove(int)} must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus {@code ConcurrentModificationExceptions}. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored." />
      <item value="* &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the {@code iterator} and {@code listIterator} methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a {@code ConcurrentModificationException} in * response to the {@code next}, {@code remove}, {@code previous}, * {@code set} or {@code add} operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration." />
      <item value="* The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results." />
      <item value="/** * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within * a {@link SpringApplication}. Multiple {@link ApplicationRunner} beans can be defined * within the same application context and can be ordered using the {@link Ordered} * interface or {@link Order @Order} annotation." />
      <item value="* Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within * a {@link SpringApplication}. Multiple {@link ApplicationRunner} beans can be defined * within the same application context and can be ordered using the {@link Ordered} * interface or {@link Order @Order} annotation." />
      <item value="/** * This value may be passed as the argument to the method {@code createSession(int sessionMode)} on the * {@code Connection} object to specify that the session should use a local transaction. * * &lt;p&gt; * This value is returned from the method {@code getAcknowledgeMode} if the session is using a local transaction, * irrespective of whether the session was created by calling the method {@code createSession(int sessionMode)} or the * method {@code createSession(boolean transacted, int acknowledgeMode)}. * * @since JMS 1.1 */" />
      <item value="* This acknowledgment mode instructs the session to lazily acknowledge the delivery of messages. This is likely to * result in the delivery of some duplicate messages if the JMS provider fails, so it should only be used by consumers * that can tolerate duplicate messages. Use of this mode can reduce session overhead by minimizing the work the session * does to prevent duplicates. */" />
      <item value="With this acknowledgment mode, the client acknowledges a consumed message by calling the message's * {@code acknowledge} method. Acknowledging a consumed message acknowledges all messages that the session has consumed. * * &lt;p&gt; * When client acknowledgment mode is used, a client may build up a large number of unacknowledged messages while * attempting to process them. A JMS provider should provide administrators with a way to limit client overrun so that * clients are not driven to resource exhaustion and ensuing failure when some resource they are using is temporarily * blocked." />
      <item value="With this acknowledgment mode, the session automatically acknowledges a client's receipt of a message either when the * session has successfully returned from a call to {@code receive} or when the message listener the session has called * to process the message successfully returns." />
      <item value="Set the JMS acknowledgement mode that is used when creating a JMS * {@link Session} to send a message. * &lt;p&gt;Default is {@link Session#AUTO_ACKNOWLEDGE}. * &lt;p&gt;Vendor-specific extensions to the acknowledgment mode can be set here as well. * &lt;p&gt;Note that inside an EJB, the parameters to the * {@code create(Queue/Topic)Session(boolean transacted, int acknowledgeMode)} method * are not taken into account. Depending on the transaction context in the EJB, * the container makes its own decisions on these values. See section 17.3.5 * of the EJB spec." />
      <item value="* Configure the destination accessor with knowledge of the JMS domain used. * Default is Point-to-Point (Queues). * &lt;p&gt;This setting primarily indicates what type of destination to resolve * if dynamic destinations are enabled. * @param pubSubDomain &quot;true&quot; for the Publish/Subscribe domain ({@link javax.jms.Topic Topics}), * &quot;false&quot; for the Point-to-Point domain ({@link javax.jms.Queue Queues}) * @see #setDestinationResolver" />
      <item value="For more information and more examples, see {@link org.junit.rules.TestRule}." />
      <item value="Run `spring-javaformat:apply` to fix." />
      <item value="* The main class to import in order to access all available {@link MockMvcBuilder MockMvcBuilders}." />
      <item value="/** * Base packages to scan for annotated components. Use {@link #scanBasePackageClasses} * for a type-safe alternative to String-based package names. * @return base packages to scan * @since 1.3.0 */" />
      <item value="* Exclude specific auto-configuration class names such that they will never be * applied." />
      <item value="* {@code FactoryBean} that creates an MyBatis {@code SqlSessionFactory}. * This is the usual way to set up a shared MyBatis {@code SqlSessionFactory} in a Spring application context; * the SqlSessionFactory can then be passed to MyBatis-based DAOs via dependency injection. * * Either {@code DataSourceTransactionManager} or {@code JtaTransactionManager} can be used for transaction * demarcation in combination with a {@code SqlSessionFactory}. JTA should be used for transactions * which span multiple databases or when container managed transactions (CMT) are being used." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="17" />
        <entry key="ENGLISH" value="17" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="disableAppKeyNotification" value="true" />
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6386d0780ccdd97b" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>